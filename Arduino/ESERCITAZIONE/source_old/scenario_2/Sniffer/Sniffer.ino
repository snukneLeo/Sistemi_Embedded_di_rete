/*
  NRF24_Sniff - An Arduino sketch to promiscuous capture all wireless
                traffic generated by Nordic Semi. NRF24L01+ modules.

  Created by Ivo Pullens, Emmission, 2014 -- www.emmission.nl

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <Arduino.h>
#include <SPI.h>
#include "CircularBuffer.h"
#include "RF24.h"
#include "RF24_config.h"

// Hardware configuration
#define RF_CE_PIN                      (7)
#define RF_CS_PIN                      (8)
#define RF_IRQ_PIN                     (2)
#define RF_IRQ                         (RF_IRQ_PIN-2)			  // Usually the interrupt = pin -2 (on uno/nano anyway)

#define RF_MAX_ADDR_WIDTH              (5)				          // Maximum address width, in bytes.
#define MAX_RF_PAYLOAD_SIZE            (13)
#define SER_BAUDRATE                   (115200)
#define PACKET_BUFFER_SIZE             (32)				          // Maximum number of packets that can be buffered between reception by NRF and transmission over serial port.
#define PIPE                           (0)				          // Pipe number to use for listening

// Startup defaults until user reconfigures it
#define DEFAULT_RF_CHANNEL             (105)
#define DEFAULT_RF_DATARATE            (RF24_2MBPS)			    // Datarate
#define DEFAULT_RF_ADDR_WIDTH          (RF_MAX_ADDR_WIDTH)  // We use all but the lowest address byte for promiscuous listening. First byte of data received will then be the node address.
#define DEFAULT_RF_ADDR_PROMISC_WIDTH  (DEFAULT_RF_ADDR_WIDTH-1)
#define DEFAULT_RADIO_ID               ((uint64_t)0xF0F0F0F000LL)
#define DEFAULT_RF_CRC_LENGTH          (2)  				        // Length (in bytes) of NRF24 CRC
#define DEFAULT_RF_PAYLOAD_SIZE        (MAX_RF_PAYLOAD_SIZE)	  // Define NRF24 payload size to maximum, so we'll slurp as many bytes as possible from the packet.

#include "NRF24_sniff_types.h"


int my_putc( char c, FILE *t )
{
  Serial.write( c );
}

// Set up nRF24L01 radio on SPI bus plus CE/CS pins
static RF24 radio(RF_CE_PIN, RF_CS_PIN);

static NRF24_packet_t bufferData[PACKET_BUFFER_SIZE];

int pos = 0;


static CircularBuffer<NRF24_packet_t> packetBuffer(bufferData, sizeof(bufferData)/sizeof(bufferData[0]));
static Serial_header_t serialHdr;
static volatile Serial_config_t conf = {
  DEFAULT_RF_CHANNEL,
  DEFAULT_RF_DATARATE,
  DEFAULT_RF_ADDR_WIDTH,
  DEFAULT_RF_ADDR_PROMISC_WIDTH,
  DEFAULT_RADIO_ID,
  DEFAULT_RF_CRC_LENGTH,
  DEFAULT_RF_PAYLOAD_SIZE
};

// First 6 bits of nRF header contain length.
#define GET_PAYLOAD_LEN(p) \
  ((p->packet[conf.addressLen - conf.addressPromiscLen] & 0xFC) >> 2)


void dissect(uint8_t arr[])
{
    uint8_t node_address = arr[0];
    uint8_t payload_length = (uint8_t)0;
    uint8_t packet_id = (uint8_t)0;
    uint8_t no_ack = ((arr[2] & 0x80) >> 7);
    union payloadTemp{
      uint8_t bytes[4];
      uint32_t raw;
      float f;
    } payload_temp;
    union payloadTemp payload_temp2;
    union payloadTime{
      uint8_t bytes[4];
      uint32_t raw;
    } payload_time;
    union payloadTime payload_time2;
    uint16_t crc = (uint16_t)0;
    
    payload_length = (arr[1] & 0xFC) >> 2;
    packet_id = arr[1] & 0x3;

    payload_temp.raw = (uint32_t)0;
    payload_temp.raw |= ((uint32_t)(arr[2] & 0x7F)) << 25;
    payload_temp.raw |= ((uint32_t)arr[3]) << 17;
    payload_temp.raw |= ((uint32_t)arr[4]) << 9;
    payload_temp.raw |= ((uint32_t)arr[5]) << 1;
    payload_temp.raw |= ((uint32_t)(arr[6] & 0x80)) >> 7;
    
    payload_temp2.raw = (uint32_t)0;
    
    payload_time.raw = (uint32_t)0;
    payload_time.raw |= ((uint32_t)(arr[6] & 0x7F)) << 25;
    payload_time.raw |= ((uint32_t)arr[7]) << 17;
    payload_time.raw |= ((uint32_t)arr[8]) << 9;
    payload_time.raw |= ((uint32_t)arr[9]) << 1;
    payload_time.raw |= ((uint32_t)(arr[10] & 0x80)) >> 7;
    payload_time2.raw = (uint32_t)0;

    // trasformiamo il dato raw in Big Endian poiché i dati vengono rappresentati in big endian,
    // anche se il dato reale viene ricevuto dalla radio in little endian.
    for (pos = 0; pos < 4; ++pos) {
      payload_temp2.bytes[pos] = payload_temp.bytes[3-pos];
      payload_time2.bytes[pos] = payload_time.bytes[3-pos];
    }
    
    crc |= ((uint16_t)(arr[10] & 0x7F)) << 9;
    crc |= ((uint16_t)arr[11]) << 1;
    crc |= ((uint16_t)(arr[12] & 0x80)) >> 7;
    
    Serial.print("Node address = ");
    stampa_bit(node_address, 8);
    Serial.print(" = ");
    Serial.println(node_address, HEX);
    Serial.print("Payload length = ");
    stampa_bit(payload_length, 6);
    Serial.println("");
    Serial.print("Packet ID = ");
    stampa_bit(packet_id, 2);
    Serial.println("");
    Serial.print("NO_ACK = ");
    stampa_bit(no_ack, 1);
    Serial.println("");
    Serial.print("Payload (temperatura) = ");
    stampa((uint8_t)((payload_temp.raw & 0xFF000000) >> 24));
    stampa((uint8_t)((payload_temp.raw & 0x00FF0000) >> 16));
    stampa((uint8_t)((payload_temp.raw & 0x0000FF00) >> 8));
    stampa((uint8_t)(payload_temp.raw & 0x000000FF));
    // stampiamo i dati così come li riceviamo, ovvero in Little Endian
    Serial.println("");
    Serial.print("Valore temperatura = ");
    Serial.print(payload_temp2.f);
    Serial.println(" gradi Celsius");
    Serial.print("Payload (timestamp) = ");
    stampa((uint8_t)((payload_time.raw & 0xFF000000) >> 24));
    stampa((uint8_t)((payload_time.raw & 0x00FF0000) >> 16));
    stampa((uint8_t)((payload_time.raw & 0x0000FF00) >> 8));
    stampa((uint8_t)(payload_time.raw & 0x000000FF));
    Serial.println("");
    Serial.print("Valore timestamp = ");
    Serial.print(payload_time2.raw);
    Serial.print(" microsecondi = ");
    Serial.print(payload_time2.raw / 1000000);
    Serial.println(" secondi");
    Serial.print("CRC = ");
    stampa((uint8_t)((crc & 0xFF00) >> 8));
    stampa((uint8_t)(crc & 0x00FF));
    Serial.println("");
    Serial.println("=======================================================");
}

// Stampa i singoli bit dato un byte e il numero di bit a partire da destra
void stampa_bit(uint8_t b, int bits) {
  uint8_t temp = (uint8_t)0;
  int i;
  for(i = 8-bits; i < 8; ++i ){
    temp = (b >> 7-i);
    temp &= (uint8_t)1;
    Serial.print(temp ? 1 : 0);
  }
}

// Stampa tutti i bit di un intero byte, inserendo uno spazio alla fine
void stampa(uint8_t b)
{
  stampa_bit(b, 8);
  Serial.print(" ");
}

static void handleNrfIrq()
{
  static uint8_t lostPacketCount = 0;
  // Loop until RX buffer(s) contain no more packets.
  while (radio.available())
  {
    if (!packetBuffer.full())
    {
      NRF24_packet_t * p = packetBuffer.getFront();
      p->timestamp = micros();  // Micros does not increase in interrupt, but it can be used.
      p->packetsLost = lostPacketCount;
      uint8_t packetLen = radio.getPayloadSize();
      if (packetLen > MAX_RF_PAYLOAD_SIZE)
      {
        packetLen = MAX_RF_PAYLOAD_SIZE;
      }

      radio.read( p->packet, packetLen );

      // Lunghezza del payload hard-coded da 51 (valore rilevato, non nella norma) a 8
      for (pos = 0; pos < MAX_RF_PAYLOAD_SIZE; ++pos) {
        if(pos == 1)
        {
          p->packet[pos] &= 3;
          p->packet[pos] |= 32;
        }
      }
      Serial.print("\n");

      size_t payload_length = GET_PAYLOAD_LEN(p);

      // Determine length of actual payload (in bytes) received from NRF24 packet control field (bits 7..2 of byte with offset 1)
      // Enhanced shockburst format is assumed!
      if (payload_length <= MAX_RF_PAYLOAD_SIZE || payload_length == 51)
      {
        // Seems like a valid packet. Enqueue it.
        packetBuffer.pushFront(p);
      }
      else
      {
        Serial.print("Packet with invalid size received: ");
        Serial.print( (uint8_t)payload_length, BIN);
        Serial.print("\n");
        // Packet with invalid size received. Could increase some counter...
      }
      lostPacketCount = 0;
    }
    else
    {
      // Buffer full. Increase lost packet counter.
      bool tx_ok, tx_fail, rx_ready;
      if (lostPacketCount < 255)
        lostPacketCount++;
      // Call 'whatHappened' to reset interrupt status.
      radio.whatHappened(tx_ok, tx_fail, rx_ready);
      // Flush buffer to drop the packet.
      radio.flush_rx();
    }
  }
}

static void activateConf( void ) {
  // Match channel & datarate
  radio.setChannel(conf.channel);
  radio.setDataRate((rf24_datarate_e)conf.rate);

  // Disable CRC & set fixed payload size to allow all packets captured to be returned by Nrf24.
  radio.disableCRC();
  radio.setPayloadSize(conf.maxPayloadSize);

  // Configure listening pipe with the 'promiscuous' address and start listening
  radio.setAddressWidth(conf.addressPromiscLen);
  radio.openReadingPipe( PIPE, conf.address >> (8*(conf.addressLen - conf.addressPromiscLen)) );
  radio.startListening();

  // Attach interrupt handler to NRF IRQ output. Overwrites any earlier handler.
  attachInterrupt(RF_IRQ, handleNrfIrq, FALLING);    // NRF24 Irq pin is active low.

  // Initialize serial header's address member to promiscuous address.
  uint64_t addr = conf.address;  // TODO: probably add some shifting!
  for (int8_t i = sizeof(serialHdr.address)-1; i >= 0; --i){
    serialHdr.address[i] = addr;
    addr >>= 8;
  }


  Serial.print("Channel:     ");
  Serial.println(conf.channel);
  Serial.print("Datarate:    ");
  switch (conf.rate){
    case 0: Serial.println("1Mb/s"); break;
    case 1: Serial.println("2Mb/s"); break;
    case 2: Serial.println("250Kb/s"); break;
  }

  Serial.print("Address:     0x");
  uint64_t adr = conf.address;
  for (int8_t i = conf.addressLen-1; i >= 0; --i){
    if ( i >= conf.addressLen - conf.addressPromiscLen ){
      Serial.print((uint8_t)(adr >> (8*i)), HEX);  //Stampa l'indirizzo di base
    }
    else{
      Serial.print("**");
    }
  }

  Serial.println("");
  Serial.print("Max payload: "); Serial.println(conf.maxPayloadSize);
  Serial.print("CRC length:  "); Serial.println(conf.crcLength);
  Serial.println("");

  radio.printDetails();

  Serial.println("");
  Serial.println("Listening...");
}






void setup(void)
{

  Serial.begin(SER_BAUDRATE);

  fdevopen( &my_putc, 0);
  Serial.println("-- RF24 Sniff --");
 
  radio.begin();

  // Disable shockburst
  radio.setAutoAck(false);
  radio.setRetries(0,0);

  // Configure nRF IRQ input
  pinMode(RF_IRQ_PIN, INPUT);

  activateConf();
}





void loop(void)
{
  while (!packetBuffer.empty())
  {
    // One or more records present
    NRF24_packet_t* p = packetBuffer.getBack();
    serialHdr.timestamp   = p->timestamp;
    serialHdr.packetsLost = p->packetsLost;
    
    uint8_t arr[13];
    
    for (pos = 0; pos < 13; ++pos){
      arr[pos] = p->packet[pos];
    }
    
    // DISSECT_BINARY

    dissect(arr);    
    
    if (p->packetsLost > 0)
    {
      Serial.print(" Lost: "); Serial.print(p->packetsLost);
    }
    Serial.println("");

    // Remove record as we're done with it.
    packetBuffer.popBack();
  }
}
